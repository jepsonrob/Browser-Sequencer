<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Canvas Stuffs">
    <meta name="author" content="Rob Jepson">

    <title>Canvas Test</title>


	<script src="Tone.js" type="text/javascript"></script> 

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>



	
<canvas id="sequencerOne" width="350" height="350">
	Canvas isn't supported in your browser!
</canvas>
<hr>
<canvas id="sequencerThree" width="350" height="150">
	Canvas isn't supported in your browser!
</canvas>
<hr>
<canvas id="sequencerTwo" width="350" height="100">
	Canvas isn't supported in your browser!
</canvas>
<hr>


<p> Control </p>

<label for="fader">Tempo</label>
<input type="range" min="60" max="240" value="120" id="fader" 
	step="1" oninput="controlChanger(0, value)">
<output for="fader" id="tempo">120</output>

	
<button onclick='start();'>start</button>
<button onclick='stop();'>stop</button>
<button onclick='clearGrid(ctx, sequencerOne);clearGrid(ctxTwo,sequencerTwo);clearGrid(ctxThree,sequencerThree);'>clear</button>

<button onclick='sequencerOne.randomizeSequencerArray(ctx);'>random one</button>
<button onclick='sequencerTwo.randomizeSequencerArray(ctxTwo);'>random two</button>
<button onclick='sequencerThree.randomizeSequencerArray(ctxThree);'>random three</button>

<hr>


<p> Volume </p>

<label for="fader">Sequencer 1</label>
<input type="range" min="-60" max="0" value="-6" id="fader" 
	step="1" oninput="volumeChanger(0, value)">
<output for="fader" id="sequencerOne">100</output>

<label for="fader">Sequencer 2</label>
<input type="range" min="-30" max="0" value="-6" id="fader" 
	step="1" oninput="volumeChanger(1, value)">
<output for="fader" id="sequencerTwo">100</output>	

<label for="fader">Sequencer 3</label>
<input type="range" min="-30" max="0" value="-6" id="fader" 
	step="1" oninput="volumeChanger(2, value)">
<output for="fader" id="sequencerThree">100</output>

<hr>

<label for="fader">Harmonicity</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('harmonicity', value)">
<output for="fader" id="harmonicity">1</output>

<label for="fader">Modulation Index</label>
<input type="range" min="0" max="50" value="10" id="fader" 
	step="1" oninput="synthChanger('modulationIndex', value)">
<output for="fader" id="modulationIndex">10</output>

<hr>

<p> Envelope </p>

<label for="fader">Attack</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('attack', value)">
<output for="fader" id="attack">50</output>

<label for="fader">Decay</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('decay', value)">
<output for="fader" id="decay">50</output>

<label for="fader">Sustain</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('sustain', value)">
<output for="fader" id="sustain">50</output>

<label for="fader">Release</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('release', value)">
<output for="fader" id="release">50</output>

<hr>

<label for="fader">Distortion</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('distortion', value)">
<output for="fader" id="distortion">100</output>


<label for="fader">Reverb</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('reverb', value)">
<output for="fader" id="reverb">100</output>

<hr>
<p> Delay <p>

<label for="fader">Dry/Wet</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('delay', value)">
<output for="fader" id="delay">100</output>	

<label for="fader">Feedback</label>
<input type="range" min="0" max="100" value="100" id="fader" 
	step="1" oninput="effectChanger('feedback', value)">
<output for="fader" id="feedback">100</output>

<label for="fader">Time</label>
<input type="range" min="0" max="100" value="100" id="fader" 
	step="1" oninput="effectChanger('time', value)">
<output for="fader" id="time">100</output>





</body>
<script>
	
	/* TO DO
	Scaling - make sure the input is responsive or figure something out there! Mobile needs to work!
	Array input & output system (save file etc?)
	Node Socket integration
	Make all the sequencers!
	front end stuff, make it look good!
	Fully realise the larger plan
	
	*/
	
	// Create canvas context
	var c = document.getElementById("sequencerOne");
	var ctx=c.getContext("2d");
	
	var cTwo = document.getElementById("sequencerTwo");
	var ctxTwo=cTwo.getContext("2d");
	
	var cThree = document.getElementById("sequencerThree");
	var ctxThree=cThree.getContext("2d");
	
	function sequencerObject(buttonsX, buttonsY, squareSize, gapSize){ // Constructor for the sequencer object
		// Declare important variables (well we're in an object, properties)
		this.squareSize = squareSize || 20;
		this.gapSize = gapSize || 1;
		this.buttonsX = buttonsX;
		this.buttonsY = buttonsY;
		this.sequencerArray = [];
		
		this.makeSequencerArray = function(){ // Makes the 2d array of 0's to represent the sequencer
				for (x=0;x< this.buttonsX;x++){
					this.sequencerArray.push([]);
					for (y=0;y<this.buttonsY;y++){
						this.sequencerArray[x].push(0)
					}
				}
			} // end function ...
			
		this.makeSequencerArray(); // ... and immediately call it!
			
		this.randomizeSequencerArray = function(canvas){ // randomizes Sequencer on/offs when called
			this.sequencerArray = [];
			for (x=0;x< this.buttonsX;x++){
				this.sequencerArray.push([]);
				for (y=0;y<this.buttonsY;y++){
					var randomizer = Math.floor(Math.random() * 10);
						if (randomizer == 1){
							this.sequencerArray[x].push(1);
						} else {
							this.sequencerArray[x].push(0);
						}	
				}
			}
			clearCanvas(canvas);
			drawGrid(canvas, this);
		} // end function
		
	} // end object constructor
	
	
	// Create the sequencers as needed
	var sequencerOne = new sequencerObject(16,16);
	var sequencerTwo = new sequencerObject(16,4);
	var sequencerThree = new sequencerObject(16,6);
	
	
	function clearCanvas(canvas){
		canvas.clearRect(0,0,500,500);    
		canvas.fillStyle = 'rgba(255,255,255,1)';  
		canvas.fillRect(0,0,500,500); 
	}
	
	function clearGrid(canvas, sequencer){
		for (var x=0; x<sequencer.buttonsX; x++){
			for (var y=0; y<sequencer.buttonsY;y++){
				sequencer.sequencerArray[x][y] = 0;
			}
		}
		clearCanvas(canvas);
		drawGrid(canvas, sequencer);
	}
	
function drawGrid(canvas, sequencer, colourOff, colourOn){ // Draws the grid and changes the colour of any buttons that are currently 'on'
	for (var x=0; x<sequencer.buttonsX; x++){
		for (var y=0; y<sequencer.buttonsY;y++){
			var loopX = ((sequencer.gapSize * 2) + sequencer.squareSize) * x;
			var loopY = ((sequencer.gapSize * 2) + sequencer.squareSize) * y;
			
				if (sequencer.sequencerArray[x][y] == 1){
					// fill with 'on' colour
					canvas.fillStyle= colourOn || "rgb(255,60,60)"; 
					canvas.fillRect(loopX,loopY,sequencer.squareSize,sequencer.squareSize);
				} else {
				// Fill with regular colour
					canvas.fillStyle = colourOff || "rgb(60,60,60)";
					canvas.fillRect(loopX,loopY,sequencer.squareSize,sequencer.squareSize);
			}
		}
	}
}

drawGrid(ctx, sequencerOne);
drawGrid(ctxTwo, sequencerTwo);
drawGrid(ctxThree, sequencerThree);


c.addEventListener("click", function(e){ // when the canvas is clicked, call the draw function and give it the coordinates.
	arrayEdit(e.layerX,e.layerY,ctx,sequencerOne);
});

cTwo.addEventListener("click", function(e){ // when the canvas is clicked, call the draw function and give it the coordinates.
	arrayEdit(e.layerX,e.layerY,ctxTwo,sequencerTwo);
});

cThree.addEventListener("click", function(e){ // when the canvas is clicked, call the draw function and give it the coordinates.
	arrayEdit(e.layerX,e.layerY,ctxThree,sequencerThree);
});

function sendArrayChanges(x,y,seq){
	
	// To Do!
}

function arrayEdit(xClick,yClick, canvas, sequencer){ // Draws the grid and changes the colour of any buttons that are currently 'on'
	for (var x=0; x<sequencer.buttonsX; x++){
		for (var y=0; y<sequencer.buttonsY;y++){
			var loopX = ((sequencer.gapSize * 2) + sequencer.squareSize) * x;
			var loopY = ((sequencer.gapSize * 2) + sequencer.squareSize) * y;
			// Yeah I'm pretty sure there's a better way of doing this bit above but oh well.
			
			if (xClick > loopX && xClick < (loopX + sequencer.squareSize) && yClick > loopY && yClick < (loopY + sequencer.squareSize)){
				sendArrayChanges(x,y,sequencer);
					if (sequencer.sequencerArray[x][y] == 0){
						sequencer.sequencerArray[x][y] = 1;
					} else {
						sequencer.sequencerArray[x][y] = 0;
					}		
			}
		}
	}
	
	drawGrid(canvas, sequencer);
}	
	
	
	
	/* AUDIO STUFF FROM THIS POINT ON! */
	
	function reverseRange(num, min, max){
		return (max + min) - num;
	}
	

	
	//setup a synth
	var reverb = new Tone.Freeverb();
	var distortion = new Tone.Distortion();
	var delay = new Tone.PingPongDelay()
	var synth = new Tone.PolySynth(12, Tone.FMSynth).chain(distortion, reverb, delay, Tone.Master);
	
	synth.set({
		"envelope" : {
			"attack" : 0.25,
			"decay" : 0,
			"sustain" : 10,
			"release" : 0.5,
		}
	});
	
	delay.wet.value = 0.5;
	distortion.wet.value = 0.5;
	reverb.wet.value = 0.5;
	
	// setup percussion
	var kick = new Tone.MembraneSynth().toMaster(); //Kick Drum
	var hat = new Tone.NoiseSynth().toMaster(); // Noise-r
	var metal = new Tone.MetalSynth().toMaster(); // I have no idea
	var snare = new Tone.NoiseSynth().chain(distortion,Tone.Master); // Noise-r
	
	snare.set({"envelope" : {
			"attack" : 0.01,
			"decay" : 0.1
	}})
	
	hat.set({"envelope" : {
			"decay" : 0.05
	}})
	
	
	
	
	//the notes
	function notes (startNote, scale, offset){
		// to do!
		// Make it so passing in a number gives you a musical note value, and allow for scales!
	}
	
	var noteNames = ["A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5", "G5", "A5", "C6", "D6", "E6", "G6", "A6"];
	// c c# d d# e f f# g g# a a# b 
	var ratios = [1, 1.122, 1.259,1.498,1.681, 2];
	var realRatios = [1, 1.059, 1.122, 1.189, 1.259, 1.334, 1.414, 1.498, 1.587, 1.681, 1.781, 1.888, 2];
	/* Sequencer - anonymous function is callback. What is a callback? It's simple! It's just a function within a function's () that gets called when the main function is done with the previous task (say, loading). Or something! I don't know!
	*/
	
	var melodyLoop = new Tone.Sequence(function(time, col){
		
		var s = sequencerOne;
		var visualTempo = col * ((s.gapSize * 2) + s.squareSize);
		var visualTempoBehind = (col - 1) * ((s.gapSize * 2) + s.squareSize)
		clearCanvas(ctx);
		drawGrid(ctx, s);
		ctx.fillStyle="rgba(0,100,0,0.3)";
		ctx.fillRect(visualTempo , 0, ((s.gapSize * 2) + s.squareSize),500);
		// fillRect ( Coordinate X, Coor Y, Height, Width)
		var column = s.sequencerArray[col];
		for (var i = 0; i < s.buttonsX; i++){
			if (column[reverseRange(i, -1, s.buttonsX)] == 1){
				synth.triggerAttackRelease(noteNames[i], "4n");
			}
		}
	}, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "16n");
	
	var fmLoop = new Tone.Sequence(function(time, col){
		
		var s = sequencerThree;
		var visualTempo = col * ((s.gapSize * 2) + s.squareSize);
		var visualTempoBehind = (col - 1) * ((s.gapSize * 2) + s.squareSize)
		clearCanvas(ctxThree);
		drawGrid(ctxThree, s);
		ctxThree.fillStyle="rgba(0,100,0,0.3)";
		ctxThree.fillRect(visualTempo , 0, ((s.gapSize * 2) + s.squareSize),500);
		var column = s.sequencerArray[col];
		for (var i = 0; i < s.buttonsX; i++){
			if (column[reverseRange(i, -1, s.buttonsY)] == 1){
				synth.set('harmonicity', ratios[i]);
				console.log(ratios[i])
			}
		}
	}, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "8n");
	
	
	
	var percLoop = new Tone.Sequence(function(time, col){
		
		var s = sequencerTwo;
		var visualTempo = col * ((s.gapSize * 2) + s.squareSize);
		var visualTempoBehind = (col - 1) * ((s.gapSize * 2) + s.squareSize)
		clearCanvas(ctxTwo);
		drawGrid(ctxTwo, s);
		ctxTwo.fillStyle="rgba(0,100,0,0.3)";
		ctxTwo.fillRect(visualTempo , 0, ((s.gapSize * 2) + s.squareSize),500);
		// fillRect ( Coordinate X, Coor Y, Height, Width)
		var column = s.sequencerArray[col];
		for (var i = 0; i < s.buttonsX; i++){
			if (column[i] == 1){
				console.log("something is certainly happening, at least. Also, 'i' is ", i)
				switch(i){
			case 0:
				metal.triggerAttackRelease("8n");
				break;
			case 1:
				hat.triggerAttackRelease("8n");
				break;
			case 2:
				snare.triggerAttackRelease("8n");
				break;
			case 3:
				kick.triggerAttackRelease("C2", "8n");
			}
		}
	}
}, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "8n");
	
	Tone.Transport.bpm.value = 120;
	Tone.Transport.start();
	
	
	
	
	function effectChanger(effectName, val){
		formattingName = '#' + effectName;
	document.querySelector(formattingName).value = val;
	if (effectName == 'distortion'){
	distortion.wet.value = val * 0.01;
	} else if (effectName =='reverb'){
		reverb.wet.value = val * 0.01;
	} else if (effectName=='time'){
			delay.delayTime.value = val * 0.01;
	} else if (effectName=='feedback'){
		delay.feedback.value = val * 0.01;
	} else if (effectName=='delay'){
		delay.wet.value = val * 0.01;
	}
	}
	
	
	function synthChanger(effectName, val){
		formattingName = '#' + effectName;
	if (effectName == 'harmonicity'){
		synth.set(effectName, val* 0.03)
		document.querySelector(formattingName).value = val * 0.03;
	} else if (effectName=='modulationIndex'){
		synth.set(effectName, val);
		document.querySelector(formattingName).value = val;
	} else if (effectName=='attack'){
		synth.set({"envelope" : {
			"attack" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='decay'){
		synth.set({"envelope" : {
			"decay" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='sustain'){
		synth.set({"envelope" : {
			"sustain" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='release'){
		synth.set({"envelope" : {
			"release" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
		}
	}
	
	function volumeChanger(sequencer, val){
	
		switch(sequencer){
		case 0:
			synth.volume.value = val;
			document.querySelector('#sequencerOne').value = val;
			break;
		case 1:
			hat.volume.value = val;
			snare.volume.value = val;
			kick.volume.value = val;
			document.querySelector('#sequencerTwo').value = val;
			break;
		case 2:
			synthTwo.volume.value = val;
			document.querySelector('#sequencerThree').value = val;
		}
	}
	
	function controlChanger(selected, val){
		switch(selected){
		case 0:
			Tone.Transport.bpm.value = val;
			document.querySelector('#tempo').value = val;
		}
	}

	function start(){
		melodyLoop.start(); 
		percLoop.start();
		fmLoop.start();
	}
	
	
	function stop(){
		fmLoop.stop();
		melodyLoop.stop();
		percLoop.stop();
	}
	
	// End of audio stuff
	</script>

</html>