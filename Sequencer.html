<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Canvas Stuffs">
    <meta name="author" content="Rob Jepson">

    <title>Canvas Test</title>


	<script src="Tone.js" type="text/javascript"></script> 

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>



	
<canvas id="sequencerOne" width="350" height="350">
	Canvas isn't supported in your browser!
</canvas>

	
<button onclick='start();'>start</button>
<button onclick='stop();'>stop</button>
<button onclick='clearGrid();'>clear</button>

<button onclick='randomSequencerArray();'>random</button>

<hr>

<label for="fader">Harmonicity</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('harmonicity', value)">
<output for="fader" id="harmonicity">1</output>

<label for="fader">Modulation Index</label>
<input type="range" min="0" max="50" value="10" id="fader" 
	step="1" oninput="synthChanger('modulationIndex', value)">
<output for="fader" id="modulationIndex">10</output>

<hr>

<p> Envelope </p>

<label for="fader">Attack</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('attack', value)">
<output for="fader" id="attack">50</output>

<label for="fader">Decay</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('decay', value)">
<output for="fader" id="decay">50</output>

<label for="fader">Sustain</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('sustain', value)">
<output for="fader" id="sustain">50</output>

<label for="fader">Release</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="synthChanger('release', value)">
<output for="fader" id="release">50</output>

<hr>

<label for="fader">Distortion</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('distortion', value)">
<output for="fader" id="distortion">100</output>


<label for="fader">Reverb</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('reverb', value)">
<output for="fader" id="reverb">100</output>

<hr>
<p> Delay <p>

<label for="fader">Dry/Wet</label>
<input type="range" min="0" max="100" value="50" id="fader" 
	step="1" oninput="effectChanger('delay', value)">
<output for="fader" id="delay">100</output>	

<label for="fader">Feedback</label>
<input type="range" min="0" max="100" value="100" id="fader" 
	step="1" oninput="effectChanger('feedback', value)">
<output for="fader" id="feedback">100</output>

<label for="fader">Time</label>
<input type="range" min="0" max="100" value="100" id="fader" 
	step="1" oninput="effectChanger('time', value)">
<output for="fader" id="time">100</output>





</body>
<script>
	/* TO DO
	Scaling - make sure the input is responsive or figure something out there! Mobile needs to work!
	Array input & output system (save file etc?)
	Turn each sequencer into an object! Ahh!
	... or just copy/paste everything. Let's give the object thing a go first!
	
	
	*/
	
	
	// Create canvas context
	var c = document.getElementById("sequencerOne");
	var ctx=c.getContext("2d");
	
	
	
	// Declare important variables
	var sequencerArray = [];
	var sequencerArrayTwo = [];
	var gapSize = 1;
	var squareSize = 20;
	var totalButtons = 16;
	
	function makeSequencerArray(array){ // Makes the 2d array of 0's to represent the sequencer
		for (x=0;x< totalButtons;x++){
			array.push([]);
			for (y=0;y<totalButtons;y++){
				array[x].push(0)
			}
		}
	}
	
	function randomSequencerArray(){ // Makes a randomly generated collection of buttons turn on.
		sequencerArray = [];
		for (x=0;x< totalButtons;x++){
			sequencerArray.push([]);
			for (y=0;y<totalButtons;y++){
				var randomizer = Math.floor(Math.random() * 10);
				if (randomizer == 1){
					sequencerArray[x].push(1);
				} else {
					sequencerArray[x].push(0);
				}
				
			}
		}
		drawGrid();
	}
	
	makeSequencerArray(sequencerArray); // Creates a 2d array for the first sequencer
	makeSequencerArray(sequencerArrayTwo); //second sequencer etc.
	
	// document.getElementById("randomz").addEventListener("click", randomSequencerSelect(0));
	
	function clearCanvas(){
		ctx.clearRect(0,0,500,500);    
		ctx.fillStyle = 'rgba(255,255,255,1)';  
		ctx.fillRect(0,0,500,500); 
	}
	
	function clearGrid(){
		for (var x=0; x<totalButtons; x++){
			for (var y=0; y<totalButtons;y++){
				sequencerArray[x][y] = 0;
			}
		}
		clearCanvas();
		drawGrid();
	}
	
function drawGrid(){ // Draws the grid and changes the colour of any buttons that are currently 'on'
	for (var x=0; x<totalButtons; x++){
		for (var y=0; y<totalButtons;y++){
			var loopX = ((gapSize * 2) + squareSize) * x;
			var loopY = ((gapSize * 2) + squareSize) * y;
			
				if (sequencerArray[x][y] == 1){
					// fill with 'on' colour
					ctx.fillStyle="rgb(255,60,60)"; 
					ctx.fillRect(loopX,loopY,squareSize,squareSize);
				} else {
				// Fill with regular colour
					ctx.fillStyle = "rgb(60,60,60)";
				ctx.fillRect(loopX,loopY,squareSize,squareSize);
			}
		}
	}
}

function arrayEdit(xClick,yClick){ // Draws the grid and changes the colour of any buttons that are currently 'on'
	for (var x=0; x<totalButtons; x++){
		for (var y=0; y<totalButtons;y++){
			var loopX = ((gapSize * 2) + squareSize) * x;
			var loopY = ((gapSize * 2) + squareSize) * y;
			
			if (xClick > loopX && xClick < (loopX + squareSize) && yClick > loopY && yClick < (loopY + squareSize)){
					if (sequencerArray[x][y] == 0){
						sequencerArray[x][y] = 1;
					} else {
						sequencerArray[x][y] = 0;
					}		
				
			}
		}
	}
	drawGrid();
}
	
	c.addEventListener("click", function(e){ // when the canvas is clicked, call the draw function and give it the coordinates.
		arrayEdit(e.layerX,e.layerY);
	});
	
	drawGrid(); // initial drawing of the grid
	
	function reverseRange(num, min, max){
		return (max + min) - num;
	}
	
	//setup a synth
	var reverb = new Tone.Freeverb();
	var distortion = new Tone.Distortion();
	var delay = new Tone.PingPongDelay()
	var synth = new Tone.PolySynth(12, Tone.FMSynth).chain(distortion, reverb, delay, Tone.Master);
	
	synth.set({
		"envelope" : {
			"attack" : 0.25,
			"decay" : 0,
			"sustain" : 10,
			"release" : 0.5,
		}
	});
	
	delay.wet.value = 0.5;
	distortion.wet.value = 0.5;
	reverb.wet.value = 0.5;
		
	
	function effectChanger(effectName, val){
		formattingName = '#' + effectName;
	document.querySelector(formattingName).value = val;
	if (effectName == 'distortion'){
	distortion.wet.value = val * 0.01;
	} else if (effectName =='reverb'){
		reverb.wet.value = val * 0.01;
	} else if (effectName=='time'){
			delay.delayTime.value = val * 0.01;
	} else if (effectName=='feedback'){
		delay.feedback.value = val * 0.01;
	} else if (effectName=='delay'){
		delay.wet.value = val * 0.01;
	}
	}
	
	
	function synthChanger(effectName, val){
		formattingName = '#' + effectName;
	if (effectName == 'harmonicity'){
		synth.set(effectName, val* 0.03)
		document.querySelector(formattingName).value = val * 0.03;
	} else if (effectName=='modulationIndex'){
		synth.set(effectName, val);
		document.querySelector(formattingName).value = val;
	} else if (effectName=='attack'){
		synth.set({"envelope" : {
			"attack" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='decay'){
		synth.set({"envelope" : {
			"decay" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='sustain'){
		synth.set({"envelope" : {
			"sustain" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
	} else if (effectName=='release'){
		synth.set({"envelope" : {
			"release" : val * 0.01
	}})
	document.querySelector(formattingName).value = val * 0.01;
		}
	}
	
	
	//the notes
	var noteNames = ["A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5", "G5", "A5", "C6", "D6", "E6", "G6", "A6"];
	
	/* Sequencer - anonymous function is callback. What is a callback? It's simple! It's just a function within a function's () that gets called when the main function is done with the previous task (say, loading). Or something! I don't know!
	*/
	
	var loop = new Tone.Sequence(function(time, col){
		var visualTempo = col * ((gapSize * 2) + squareSize);
		var visualTempoBehind = (col - 1) * ((gapSize * 2) + squareSize)
		clearCanvas();
		drawGrid();
		ctx.fillStyle="rgba(0,100,0,0.3)";
		ctx.fillRect(visualTempo , 0, ((gapSize * 2) + squareSize),500);
		// fillRect ( Coordinate X, Coor Y, Height, Width)
		var column = sequencerArray[col];
		for (var i = 0; i < totalButtons; i++){
			if (column[reverseRange(i, -1, totalButtons)] === 1){
				synth.triggerAttackRelease(noteNames[i], "4n");
			}
		}
	}, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "8n");
	
	Tone.Transport.bpm.value = 120;
	Tone.Transport.start();

	function start(){
		loop.start(); 
	}
	
	function stop(){
		loop.stop();
	}


	
	
	
	// End of audio stuff
	</script>

</html>